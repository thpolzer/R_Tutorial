getwd()
### INTRODUCTION ###
# In R there is no such thing as a scalar. Even a single value is stored as an object, and the basic data structure for an object is a vector.
# A variable with one single in a one-dimensional-vector.
# Example:
a <- 1.3
# Retrieving the first element:
show(a[1])
length(a)
mode(a)
v1 <- c(1,2,3)
v2 <- vector("USA","Portugal","Bolivia","Egypt","India","New Zealand")
?vector()
v2 <- vector(mode = "integer",length = 2)
v2[1] <- 12
v2[2] <- 89
v2[1]
v2[5]
b <- c(seq(1,6))
b
c <- seq(8,47)
c
v1+v2
v3 <- c(1,v2)
v3
v3 <- c()
i <- 1
v3 <- c()
while (i <-11){
v3 <- c(v3,i)
i <- i+1
}
i <- 1
v3 <- c()
while (i < 11){
v3 <- c(v3,i)
i <- i+1
}
v3
seq (1:8)
rep("Thomas",12)
# 3.2 Repetition using rep(element, number of repetitions)
rep("Thomas",12)
## 2. Dynamically fill up an initially empty vector
# sometimes you need to create an empty vector and then fill it up in a loop
i <- 1
v3 <- c()
while (i < 11){
v3 <- c(v3,i)
i <- i+1
}
## 3. Special vectors
# 3.1 Sequence using seq(<first element included>:<last element included>)
seq (1:8)
# 3.2 Repetition using rep(element, number of repetitions)
rep("Thomas",12)
### INTRODUCTION ###
# In R there is no such thing as a scalar. Even a single value is stored as an object, and the basic data structure for an object is a vector.
# A variable with one single in a one-dimensional-vector.
# Example:
a <- 1.3
# Retrieving the first element:
show(a[1])
length(a)
# Each element within a vector needs come with the same data type (in R a data type is called "mode"). Data type can be checked using the
# mode() function:
mode(a)
# atomic modes in R (same as "primitive data types" in other languages: integer, numeric (floating-point number), character (string),
# logical (boolean), complex
## 1. create a vector
v1 <- c(1,2,3)
v2 <- vector(mode = "integer",length = 2)
v2[1] <- 12
v2[2] <- 89
## 2. Dynamically fill up an initially empty vector
# sometimes you need to create an empty vector and then fill it up in a loop
i <- 1
v3 <- c()
while (i < 11){
v3 <- c(v3,i)
i <- i+1
}
## 3. Special vectors
# 3.1 Sequence using seq(<first element included>:<last element included>)
seq (1:8)
# 3.2 Repetition using rep(element, number of repetitions)
rep("Thomas",12)
c1 <- c(1,2,3)
c2 <- c(4,5,6)
c1 + c2
c1 * c2
c3 <- c(3,2)
c4 <- c (5,3,2)
c3 + c4
c3 * c4
c5 <- seq(1011:1782)
c5 <- seq(1011:1782)
c5[1]
?seq()
seq (5,8)
c5 <- seq(1011,1782)
?mod
4 % 2
4 %% 2
4 %%12
c5 <- seq(1011,1782)
if (any(c5 %% 3 == 0)) print ("Gude"
if (any(c5 %% 3 == 0)) print ("Gude")
if (any(c5 %% 3 == 0)) print ("The vector includes elements that are multiples of 3")
# 5.2 all()
if (all(c5 %% 3 == 0)) print ("The vector exclusively includes elements that are multiples of 3") else print ("Shit")
c5[< 1]
c5[[< 1500]]
c5[12]
c5[12:19]
c5 [17:length(c5)]
c5[c(1,201,579,715)]
c5[c(1,1,18)] # Duplicates are allowed
as.matrix(c5)
c5[-19]
c5[c(-1,-3,-5)]
c6 <- c(4,6,8)
names(c6)
names(c6) <- c("a","b","c")
names(c6)
names(c6[]) <- "FirstNumber"
names(c6)
names(c6[1]) <- "FirstNumber"
names(c6)
names(c6[1]) <- c("FirstNumber")
names(c6)
names(c6[1])
names(c6[1]) = "Gude"
names(c6[1])
names(c6)
c6[1]
getwd()
getwd()
setwd("~/R_Tutorial")
household <- read.csv("testdata/03_household_data.csv",header=TRUE)
View(household)
setwd("~/R_Tutorial")
#### 1. Load csv file from filesystem ####
# Pls keep in mind:
#   Use read.csv when Comma is default separator and dot is used for decimals
#   Use read.csv2 when Semicolon is default separator and Comma is used for decimals
cardata1 <- read.csv("testdata/01_car1.csv",header=TRUE)
cardata2 <- read.csv2("testdata/02_car1.csv",header=TRUE)
household <- read.csv("testdata/03_household_data.csv",header=TRUE)
#### 2. Load table from database ####
# in this example we'll be using MySQL database
# if not done before you need to install the RMySQL package first => install.packages("RMySQL")
library(RMySQL)
conn = dbConnect(MySQL(), user='ruser', password='BqWy6015', dbname='rtutorial', host='localhost')
## 2.1 list all tables
tables <- dbListTables(conn = conn)
## 2.2 retrieving data
# 2.2.1 fetch data
rs <- dbSendQuery(conn, "select * from cardata")
# 2.2.2 convert result into R specific dataframe
# The n in the function specifies the number of records to retrieve, using n=-1 retrieves all pending records
cardata <- fetch(rs,n=-1)
## 2.3 write table
# code has been commented out since repeated calls lead to a database error (creating a table that already exists)
#res <- dbWriteTable(conn, name='cardata_prices1', value=cardata2)
## 2.4 disconnect from database
dbDisconnect(conn)
rm(conn,rs,tables)
#### 3. Save data from existing workspace into a file and load it into new workspace
## 3.1 Textual format
# 3.1.1 saving and loading one single object: Use dput() function
# The file to be created needs to come with extension ".R"
dput(cardata1,file = "workspacedata/cardata1.R")
# if you want to load this data into your new workspace load it with dget() function
rm(cardata1) # remove cardata1 from workspace to see the effect in the next command
cardata1 <- dget("workspacedata/cardata1.R")
show(cardata1)
# 3.1.2 saving and loading multiple objects: Use dump() function (note: object names to be put in quotes inside the vector)
dump(c("cardata1","cardata2"),file = "workspacedata/cardata_objects.R")
# if you want to load this data into your new workspace load it with source() function which is the inverse of dump()
rm(cardata1,cardata2) # remove cardata1 and cardata2 from workspace to see the effect in the next command
source("workspacedata/cardata_objects.R")
## 3.2 Binary format
# with numeric data, one can often lose precision when converting to and from a textual format, so it’s better to stick
# with a binary format.
# 3.2.1 saving and loading one single object: Use save() function, use ".rda" extension for the file
save(cardata1,cardata2, file = "workspacedata/cardata_binaryFormat.rda")
# if you want to load this data into your new workspace load it with load() function
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata_binaryFormat.rda") # workspace is back again
# 3.2.2 saving and loading multiple object: Use save() function, use ".RData" extension for the file (=convention)
save.image(file = "workspacedata/cardata.RData")
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata.RData") # workspace is back again
#### 4. Garbage Collector
# it is important to note that the two are very different in that gc does not delete any variables that you are still using -
# it only frees up the memory for ones that you no longer have access to (whether removed using rm() or, say, created in a function
# that has since returned). Running gc() will never make you lose variables.
# The question of whether you should call gc() after calling rm(), though, is a good one. The documentation
# https://stat.ethz.ch/R-manual/R-patched/library/base/html/gc.html
# for gc helpfully notes:
# A call of gc causes a garbage collection to take place.
# This will also take place automatically without user intervention, and the primary purpose of calling gc is for the report on
# memory usage.
# However, it can be useful to call gc after a large object has been removed, as this may prompt R to return memory to the operating system.
rm(list=ls())
gc()
load("/workspacedata/cardata.RData")
load("workspacedata/cardata.RData")
setwd("~/R_Tutorial")
#### 1. Load csv file from filesystem ####
# Pls keep in mind:
#   Use read.csv when Comma is default separator and dot is used for decimals
#   Use read.csv2 when Semicolon is default separator and Comma is used for decimals
cardata1 <- read.csv("testdata/01_car1.csv",header=TRUE)
cardata2 <- read.csv2("testdata/02_car1.csv",header=TRUE)
householddata <- read.csv("testdata/03_household_data.csv",header=TRUE)
#### 2. Load table from database ####
# in this example we'll be using MySQL database
# if not done before you need to install the RMySQL package first => install.packages("RMySQL")
library(RMySQL)
conn = dbConnect(MySQL(), user='ruser', password='BqWy6015', dbname='rtutorial', host='localhost')
## 2.1 list all tables
tables <- dbListTables(conn = conn)
## 2.2 retrieving data
# 2.2.1 fetch data
rs <- dbSendQuery(conn, "select * from cardata")
# 2.2.2 convert result into R specific dataframe
# The n in the function specifies the number of records to retrieve, using n=-1 retrieves all pending records
cardata <- fetch(rs,n=-1)
## 2.3 write table
# code has been commented out since repeated calls lead to a database error (creating a table that already exists)
#res <- dbWriteTable(conn, name='cardata_prices1', value=cardata2)
## 2.4 disconnect from database
dbDisconnect(conn)
rm(conn,rs,tables)
#### 3. Save data from existing workspace into a file and load it into new workspace
## 3.1 Textual format
# 3.1.1 saving and loading one single object: Use dput() function
# The file to be created needs to come with extension ".R"
dput(cardata1,file = "workspacedata/cardata1.R")
# if you want to load this data into your new workspace load it with dget() function
rm(cardata1) # remove cardata1 from workspace to see the effect in the next command
cardata1 <- dget("workspacedata/cardata1.R")
show(cardata1)
# 3.1.2 saving and loading multiple objects: Use dump() function (note: object names to be put in quotes inside the vector)
dump(c("cardata1","cardata2"),file = "workspacedata/cardata_objects.R")
# if you want to load this data into your new workspace load it with source() function which is the inverse of dump()
rm(cardata1,cardata2) # remove cardata1 and cardata2 from workspace to see the effect in the next command
source("workspacedata/cardata_objects.R")
## 3.2 Binary format
# with numeric data, one can often lose precision when converting to and from a textual format, so it’s better to stick
# with a binary format.
# 3.2.1 saving and loading one single object: Use save() function, use ".rda" extension for the file
save(cardata1,cardata2,file = "workspacedata/cardata_binaryFormat.rda")
save(householddata,file = "workspacedata/householddata.rda")
# if you want to load this data into your new workspace load it with load() function
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata_binaryFormat.rda") # workspace is back again
# 3.2.2 saving and loading multiple object: Use save() function, use ".RData" extension for the file (=convention)
save.image(file = "workspacedata/cardata.RData")
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata.RData") # workspace is back again
#### 4. Garbage Collector
# it is important to note that the two are very different in that gc does not delete any variables that you are still using -
# it only frees up the memory for ones that you no longer have access to (whether removed using rm() or, say, created in a function
# that has since returned). Running gc() will never make you lose variables.
# The question of whether you should call gc() after calling rm(), though, is a good one. The documentation
# https://stat.ethz.ch/R-manual/R-patched/library/base/html/gc.html
# for gc helpfully notes:
# A call of gc causes a garbage collection to take place.
# This will also take place automatically without user intervention, and the primary purpose of calling gc is for the report on
# memory usage.
# However, it can be useful to call gc after a large object has been removed, as this may prompt R to return memory to the operating system.
rm(list=ls())
gc()
