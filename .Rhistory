dump(c("cardata1","cardata2"),file = "workspacedata/cardata_objects.R")
# if you want to load this data into your new workspace load it with source() function which is the inverse of dump()
rm(cardata1,cardata2) # remove cardata1 and cardata2 from workspace to see the effect in the next command
source("workspacedata/cardata_objects.R")
## 3.2 Binary format
# with numeric data, one can often lose precision when converting to and from a textual format, so it’s better to stick
# with a binary format.
# 3.2.1 saving and loading one single object: Use save() function, use ".rda" extension for the file
save(cardata1,cardata2, file = "workspacedata/cardata_binaryFormat.rda")
# if you want to load this data into your new workspace load it with load() function
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata_binaryFormat.rda") # workspace is back again
# 3.2.2 saving and loading multiple object: Use save() function, use ".RData" extension for the file (=convention)
save.image(file = "workspacedata/cardata.RData")
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata.RData") # workspace is back again
#### 4. Garbage Collector
# it is important to note that the two are very different in that gc does not delete any variables that you are still using -
# it only frees up the memory for ones that you no longer have access to (whether removed using rm() or, say, created in a function
# that has since returned). Running gc() will never make you lose variables.
# The question of whether you should call gc() after calling rm(), though, is a good one. The documentation
# https://stat.ethz.ch/R-manual/R-patched/library/base/html/gc.html
# for gc helpfully notes:
# A call of gc causes a garbage collection to take place.
# This will also take place automatically without user intervention, and the primary purpose of calling gc is for the report on
# memory usage.
# However, it can be useful to call gc after a large object has been removed, as this may prompt R to return memory to the operating system.
rm(list=ls())
gc()
load("/workspacedata/cardata.RData")
load("workspacedata/cardata.RData")
setwd("~/R_Tutorial")
#### 1. Load csv file from filesystem ####
# Pls keep in mind:
#   Use read.csv when Comma is default separator and dot is used for decimals
#   Use read.csv2 when Semicolon is default separator and Comma is used for decimals
cardata1 <- read.csv("testdata/01_car1.csv",header=TRUE)
cardata2 <- read.csv2("testdata/02_car1.csv",header=TRUE)
householddata <- read.csv("testdata/03_household_data.csv",header=TRUE)
#### 2. Load table from database ####
# in this example we'll be using MySQL database
# if not done before you need to install the RMySQL package first => install.packages("RMySQL")
library(RMySQL)
conn = dbConnect(MySQL(), user='ruser', password='BqWy6015', dbname='rtutorial', host='localhost')
## 2.1 list all tables
tables <- dbListTables(conn = conn)
## 2.2 retrieving data
# 2.2.1 fetch data
rs <- dbSendQuery(conn, "select * from cardata")
# 2.2.2 convert result into R specific dataframe
# The n in the function specifies the number of records to retrieve, using n=-1 retrieves all pending records
cardata <- fetch(rs,n=-1)
## 2.3 write table
# code has been commented out since repeated calls lead to a database error (creating a table that already exists)
#res <- dbWriteTable(conn, name='cardata_prices1', value=cardata2)
## 2.4 disconnect from database
dbDisconnect(conn)
rm(conn,rs,tables)
#### 3. Save data from existing workspace into a file and load it into new workspace
## 3.1 Textual format
# 3.1.1 saving and loading one single object: Use dput() function
# The file to be created needs to come with extension ".R"
dput(cardata1,file = "workspacedata/cardata1.R")
# if you want to load this data into your new workspace load it with dget() function
rm(cardata1) # remove cardata1 from workspace to see the effect in the next command
cardata1 <- dget("workspacedata/cardata1.R")
show(cardata1)
# 3.1.2 saving and loading multiple objects: Use dump() function (note: object names to be put in quotes inside the vector)
dump(c("cardata1","cardata2"),file = "workspacedata/cardata_objects.R")
# if you want to load this data into your new workspace load it with source() function which is the inverse of dump()
rm(cardata1,cardata2) # remove cardata1 and cardata2 from workspace to see the effect in the next command
source("workspacedata/cardata_objects.R")
## 3.2 Binary format
# with numeric data, one can often lose precision when converting to and from a textual format, so it’s better to stick
# with a binary format.
# 3.2.1 saving and loading one single object: Use save() function, use ".rda" extension for the file
save(cardata1,cardata2,file = "workspacedata/cardata_binaryFormat.rda")
save(householddata,file = "workspacedata/householddata.rda")
# if you want to load this data into your new workspace load it with load() function
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata_binaryFormat.rda") # workspace is back again
# 3.2.2 saving and loading multiple object: Use save() function, use ".RData" extension for the file (=convention)
save.image(file = "workspacedata/cardata.RData")
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata.RData") # workspace is back again
#### 4. Garbage Collector
# it is important to note that the two are very different in that gc does not delete any variables that you are still using -
# it only frees up the memory for ones that you no longer have access to (whether removed using rm() or, say, created in a function
# that has since returned). Running gc() will never make you lose variables.
# The question of whether you should call gc() after calling rm(), though, is a good one. The documentation
# https://stat.ethz.ch/R-manual/R-patched/library/base/html/gc.html
# for gc helpfully notes:
# A call of gc causes a garbage collection to take place.
# This will also take place automatically without user intervention, and the primary purpose of calling gc is for the report on
# memory usage.
# However, it can be useful to call gc after a large object has been removed, as this may prompt R to return memory to the operating system.
rm(list=ls())
gc()
cardata1 <- read.csv("testdata/01_car1.csv",header=TRUE)
cardata2 <- read.csv2("testdata/02_car1.csv",header=TRUE)
householddata <- read.csv("testdata/03_household_data.csv",header=TRUE)
# if not done before you need to install the RMySQL package first => install.packages("RMySQL")
library(RMySQL)
conn = dbConnect(MySQL(), user='ruser', password='BqWy6015', dbname='rtutorial', host='localhost')
## 2.1 list all tables
tables <- dbListTables(conn = conn)
## 2.2 retrieving data
# 2.2.1 fetch data
rs <- dbSendQuery(conn, "select * from cardata")
# 2.2.2 convert result into R specific dataframe
# The n in the function specifies the number of records to retrieve, using n=-1 retrieves all pending records
cardata <- fetch(rs,n=-1)
#res <- dbWriteTable(conn, name='cardata_prices1', value=cardata2)
## 2.4 disconnect from database
dbDisconnect(conn)
rm(conn,rs,tables)
# The file to be created needs to come with extension ".R"
dput(cardata1,file = "workspacedata/cardata1.R")
# if you want to load this data into your new workspace load it with dget() function
rm(cardata1) # remove cardata1 from workspace to see the effect in the next command
cardata1 <- dget("workspacedata/cardata1.R")
show(cardata1)
# 3.1.2 saving and loading multiple objects: Use dump() function (note: object names to be put in quotes inside the vector)
dump(c("cardata1","cardata2"),file = "workspacedata/cardata_objects.R")
# if you want to load this data into your new workspace load it with source() function which is the inverse of dump()
rm(cardata1,cardata2) # remove cardata1 and cardata2 from workspace to see the effect in the next command
source("workspacedata/cardata_objects.R")
save(cardata1,cardata2,file = "workspacedata/cardata_binaryFormat.rda")
save(householddata,file = "workspacedata/householddata.rda")
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata_binaryFormat.rda") # workspace is back again
# 3.2.2 saving and loading multiple object: Use save() function, use ".RData" extension for the file (=convention)
save.image(file = "workspacedata/cardata.RData")
rm(list=ls()) # clear workspace to see the effect in the next command
load("workspacedata/cardata.RData") # workspace is back again
rm(list=ls())
gc()
load("workspacedata/household.rda")
getwd()
load("workspacedata/householddata.rda")
View(householddata)
as.matrix(householddata)
M1 <- matrix(1:10,nrow = 2, ncol = 5)
M1
essary
# 1. Create a matrix
# 1.1 Manually
M1 <- matrix(1:10,nrow = 2, ncol = 5) # specifying ncol is actually not necessary
M2 <- matrix(1:10,nrow = 2) # specifying ncol is actually not necessary
M3 <- matrix(1:10,nrow = 2, byrow = F) # specifying ncol is actually not necessary
M3
M2
M3 <- matrix(1:10,nrow = 2, byrow = T) # specifying ncol is actually not necessary
M3
M1
# 1.1 Manually
M1 <- matrix(1:10,nrow = 2, ncol = 5) # specifying ncol is actually not necessary
M2 <- matrix(1:10,nrow = 2) # specifying ncol is actually not necessary
# Though internal storage of a matrix is in column-major order, we can use the byrow argument in matrix()
# to TRUE in order to specify that the data we are using to fill a matrix be interpreted as being in row-major
# order. Pls check:
M3 <- matrix(1:10,nrow = 2, byrow = T)
M4 <- matrix(nrow = 20,ncol = 12)
i,j = 1
i = j = 1
i = j <- 1
i
j
cols = rows <- 1
nrow(M4)
cols = rows <- 1
while (cols <= ncol(M4)){
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M[rows,cols]=1.2 else M[rows,cols]=-1.5
rows = rows +1
}
cols = cols + 1
}
cols = rows <- 1
while (cols <= ncol(M4)){
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M4[rows,cols]=1.2 else M4[rows,cols]=-1.5
rows = rows +1
}
cols = cols + 1
}
M4
cols = rows <- 1
while (cols <= ncol(M4)){
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M4[rows,cols]=1.2 else M4[rows,cols]=-1.5
rows <- rows +1
}
cols <- cols + 1
}
M4
while (cols <= ncol(M4)){
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M4[rows,cols]=1.2 else M4[rows,cols]=-1.5
rows <- rows +1
}
cols <- cols + 1
print(cols)
}
cols
rows
cols = rows <- 1
cols
rows
cols <- 1
while (cols <= ncol(M4)){
rows <- 1
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M4[rows,cols]=1.2 else M4[rows,cols]=-1.5
rows <- rows +1
}
cols <- cols +1
}
M4
load("workspacedata/householddata.rda")
rm(list = ls())
### INTRODUCTION ###
# A matrix is actually a multidimensional vector. In general, multidimensional vectors in R are called arrays. As such, a two-dimensional-
# array is also called a matrix.
# Matrix row and column subscripts begin with 1, so for instance the upper-left corner of the matrix a is
# denoted a[1,1]. The internal linear storage of a matrix is in column-major order, meaning that first all of
# column 1 is stored, then all of column 2, etc.
# 1. Create a matrix
# 1.1 Manually
M1 <- matrix(1:10,nrow = 2, ncol = 5) # specifying ncol is actually not necessary
M2 <- matrix(1:10,nrow = 2) # specifying ncol is actually not necessary
# Though internal storage of a matrix is in column-major order, we can use the byrow argument in matrix()
# to TRUE in order to specify that the data we are using to fill a matrix be interpreted as being in row-major
# order. Pls check:
M3 <- matrix(1:10,nrow = 2, byrow = T)
# in addition, we can just specify the number of rows and columns and add the elements specifically
M4 <- matrix(nrow = 20,ncol = 12)
cols <- 1
while (cols <= ncol(M4)){
rows <- 1
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M4[rows,cols]=1.2 else M4[rows,cols]=-1.5
rows <- rows +1
}
cols <- cols +1
}
load("workspacedata/householddata.rda")
M1 <- as.matrix(householddata)
### INTRODUCTION ###
# A matrix is actually a multidimensional vector. In general, multidimensional vectors in R are called arrays. As such, a two-dimensional-
# array is also called a matrix.
# Matrix row and column subscripts begin with 1, so for instance the upper-left corner of the matrix a is
# denoted a[1,1]. The internal linear storage of a matrix is in column-major order, meaning that first all of
# column 1 is stored, then all of column 2, etc.
# 1. Create a matrix
# 1.1 Manually
M1 <- matrix(1:10,nrow = 2, ncol = 5) # specifying ncol is actually not necessary
M2 <- matrix(1:10,nrow = 2) # specifying ncol is actually not necessary
# Though internal storage of a matrix is in column-major order, we can use the byrow argument in matrix()
# to TRUE in order to specify that the data we are using to fill a matrix be interpreted as being in row-major
# order. Pls check:
M3 <- matrix(1:10,nrow = 2, byrow = T)
# in addition, we can just specify the number of rows and columns and add the elements specifically
M4 <- matrix(nrow = 20,ncol = 12)
cols <- 1
while (cols <= ncol(M4)){
rows <- 1
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M4[rows,cols]=1.2 else M4[rows,cols]=-1.5
rows <- rows +1
}
cols <- cols +1
}
rm(list = ls())
load("workspacedata/householddata.rda")
M1 <- as.matrix(householddata)
M1
list <- c(1:22)
M2 <- as.matrix(list)
M2
simpleList <- list(c(1:22))
M2 <- as.matrix(simpleList)
M2
simpleList[1:22]
simpleList <- list(1:22)
simpleList
M2 <- as.matrix(simpleList)
M2
M2 <- as.matrix(simpleList[1:22])
M2
simpleVector <- 1:22
simpleVector
M2 <- as.matrix(simpleVector)
M2
M2[1,3]
M2[3,1]
M3[, c(2,4,6)]
M1[, c(1,3)]
M1[1:5,]
M1[2,3] # the element in the second row and the 3rd column
rowMeans(M1)
mean(M1)
colMeans(M1)
mean(sum(colMeans(M1)rowMeans(M1)))
mean(sum(colMeans(M1),rowMeans(M1)))
mean(colMeans(M1),rowMeans(M1))
mean(c(colMeans(M1),rowMeans(M1))
rm(list = ls())
mean (c(1,2))
mean(c(colMeans(M1),rowMeans(M1)))
mean(M1)
meanRows <- rowMeans(M1)
meanColumns <- colMeans(M1)
meanRows
meanColumns
M2 <- M1[1:4,]
M2
rownames(M2) <- c("Person1","Person2","Person3","Person4")
M2
on
one
M3 <- M1[1:6,]
M3
M4 <- M3[c(-(1:3)),]
M4
cbind(M4,newColumn)
newColumn <- c(0,1,1)
cbind(M4,newColumn)
M4
M4 <- cbind(M4,newColumn)
M4
names(M4[4])
names(M4[,4])
names(M4)
colnames(M4)
colnames(M4[4])
M4names <- colnames(M4)
M4names[1]
M4names[4]
M4names[4] <- number_pets
M4names[4] <- "number_pets"
M4names
colnames(M4) <- M4names
M4
newRow <- c(1,91122.10,1,0)
M4 <- rbind(newRow,M4)
M4
rm(M4)
M4 <- M3[c(-(1:3)),]
# 4.2 Adding elements to a matrix
# use cbind() or rbind() function
newColumn <- c(0,1,1)
M4 <- cbind(M4,newColumn)
# adding new name for 4th column
M4names <- colnames(M4)
M4names[4] <- "number_pets"
colnames(M4) <- M4names
M4 <- rbind(c(1,91122.10,1,0),M4)
M4
M4 <- rbind(M4, c(2,111226,2,2),)
M4 <- rbind(M4, c(2,111226,2,2))
M4
### INTRODUCTION ###
# A matrix is actually a multidimensional vector. In general, multidimensional vectors in R are called arrays. As such, a two-dimensional-
# array is also called a matrix.
# Matrix row and column subscripts begin with 1, so for instance the upper-left corner of the matrix a is
# denoted a[1,1]. The internal linear storage of a matrix is in column-major order, meaning that first all of
# column 1 is stored, then all of column 2, etc.
# ATTENTION: In contrast to a vector, a list or a dataframe all elements of a matrix need to come with a NUMERIC DATATYPE (=mode)
# 1. Create a matrix
# 1.1 Manually
M1 <- matrix(1:10,nrow = 2, ncol = 5) # specifying ncol is actually not necessary
M2 <- matrix(1:10,nrow = 2) # specifying ncol is actually not necessary
# Though internal storage of a matrix is in column-major order, we can use the byrow argument in matrix()
# to TRUE in order to specify that the data we are using to fill a matrix be interpreted as being in row-major
# order. Pls check:
M3 <- matrix(1:10,nrow = 2, byrow = T)
# in addition, we can just specify the number of rows and columns and add the elements specifically
M4 <- matrix(nrow = 20,ncol = 12)
cols <- 1
while (cols <= ncol(M4)){
rows <- 1
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M4[rows,cols]=1.2 else M4[rows,cols]=-1.5
rows <- rows +1
}
cols <- cols +1
}
rm(list = ls())
# 1.2 Converting a dataframe or a vector into s matrix using the as.matrix() function
load("workspacedata/householddata.rda")
M1 <- as.matrix(householddata)
simpleVector <- 1:22
M2 <- as.matrix(simpleVector)
# 2. Matrix Indexing
# Use the bracket operator
M1[, c(1,3)] # all rows, columns 1 and 3
M1[1:5,] # rows 1 to 5, all columns
M1[2,3] # the element in the second row and the 3rd column
# 3. Matrix Row and Column functions
# 3.1 mean functions
# mean(<M>) returns the mean of all elements. Sometimes it is useful to get the mean per row or/ and per column
mean(M1)
meanRows <- rowMeans(M1)
meanColumns <- colMeans(M1)
# names
# If required, one can assign names to both rows and columns of a matrix
M2 <- M1[1:4,]
rownames(M2) <- c("Person1","Person2","Person3","Person4")
# 4. Enhancing a matrix/ Removing elements of a matrix
# 4.1 removing elements from a matrix
# use indexing as described in 2. to create a new scaled down matrix (use same variable name as before if you want to overwrite)
M3 <- M1[1:6,]
M4 <- M3[c(-(1:3)),]
# 4.2 Adding elements to a matrix
# use cbind() or rbind() function
# 4.2.1 adding a column
newColumn <- c(0,1,1)
M4 <- cbind(M4,newColumn)
# adding new name for 4th column
M4names <- colnames(M4)
M4names[4] <- "number_pets"
colnames(M4) <- M4names
# adding a row
M4 <- rbind(c(1,91122.10,1,0),M4)
M4 <- rbind(M4, c(2,111226,2,2))
rm(M1,M2)
### INTRODUCTION ###
# A matrix is actually a multidimensional vector. In general, multidimensional vectors in R are called arrays. As such, a two-dimensional-
# array is also called a matrix.
# Matrix row and column subscripts begin with 1, so for instance the upper-left corner of the matrix a is
# denoted a[1,1]. The internal linear storage of a matrix is in column-major order, meaning that first all of
# column 1 is stored, then all of column 2, etc.
# ATTENTION: In contrast to a vector, a list or a dataframe all elements of a matrix need to come with a NUMERIC DATATYPE (=mode)
# 1. Create a matrix
# 1.1 Manually
M1 <- matrix(1:10,nrow = 2, ncol = 5) # specifying ncol is actually not necessary
M2 <- matrix(1:10,nrow = 2) # specifying ncol is actually not necessary
# Though internal storage of a matrix is in column-major order, we can use the byrow argument in matrix()
# to TRUE in order to specify that the data we are using to fill a matrix be interpreted as being in row-major
# order. Pls check:
M3 <- matrix(1:10,nrow = 2, byrow = T)
# in addition, we can just specify the number of rows and columns and add the elements specifically
M4 <- matrix(nrow = 20,ncol = 12)
cols <- 1
while (cols <= ncol(M4)){
rows <- 1
while (rows <= nrow(M4)) {
if (rows %% 2 == 0 || rows %% 3 == 0) M4[rows,cols]=1.2 else M4[rows,cols]=-1.5
rows <- rows +1
}
cols <- cols +1
}
rm(list = ls())
# 1.2 Converting a dataframe or a vector into s matrix using the as.matrix() function
load("workspacedata/householddata.rda")
M1 <- as.matrix(householddata)
simpleVector <- 1:22
M2 <- as.matrix(simpleVector)
# 2. Matrix Indexing
# Use the bracket operator
M1[, c(1,3)] # all rows, columns 1 and 3
M1[1:5,] # rows 1 to 5, all columns
M1[2,3] # the element in the second row and the 3rd column
# 3. Matrix Row and Column functions
# 3.1 mean functions
# mean(<M>) returns the mean of all elements. Sometimes it is useful to get the mean per row or/ and per column
mean(M1)
meanRows <- rowMeans(M1)
meanColumns <- colMeans(M1)
# names
# If required, one can assign names to both rows and columns of a matrix
M2 <- M1[1:4,]
rownames(M2) <- c("Person1","Person2","Person3","Person4")
# 4. Enhancing a matrix/ Removing elements of a matrix
# 4.1 removing elements from a matrix
# use indexing as described in 2. to create a new scaled down matrix (use same variable name as before if you want to overwrite)
M3 <- M1[1:6,]
M4 <- M3[c(-(1:3)),]
# 4.2 Adding elements to a matrix
# use cbind() or rbind() function
# 4.2.1 adding a column
newColumn <- c(0,1,1)
M4 <- cbind(M4,newColumn)
# adding new name for 4th column
M4names <- colnames(M4)
M4names[4] <- "number_pets"
colnames(M4) <- M4names
# adding a row
M4 <- rbind(c(1,91122.10,1,0),M4)
M4 <- rbind(M4, c(2,111226,2,2))
rm(M1,M2)
rm(M3)
M1 <- matrix(data=c(1,2,3,4,5,6),nrow=2,ncol=3)
M2 <- matrix(data=c(7,8,9,10,11,12),nrow=2,ncol=3)
M3 <- matrix(data=c(-1,-2,-3,1,2,3),nrow=3,ncol = 2)
M_sum <- M1 + M2
M_Sub <- M1 - M2
M1_scalarMult <- 3 * M1
M2_scalarDiv <- M2/4
vect <- c(1,2,3)
M1_vectMult <- M1 %*% vect
vals <- matrix(c(rep(1,4),c(2104,1416,1534,852)),nrow=4,ncol = 2)
result <- vals %*% c(-40,0.25)
M_matrixMult <- M1 %*% M3
Equations <- matrix(c(-40,0.25,200,0.1,-150,0.4),nrow=2,ncol=3)
new_result <- vals %*% Equations
M4 <- matrix(c(1,2,3,4),nrow = 2, ncol = 2)
det(M4)
solve(M4)
M_transpose <- t(M1)
rm(list=ls())
