#save(input,file="C:/Users/tpolzer/OneDrive - DXC Production/Documents/Analytics_Training_UseCase/Data/TimeSeries/inputdata_timeseries_updated.rda")
#load("C:/Users/tpolzer/OneDrive - DXC Production/Documents/Analytics_Training_UseCase/Data/TimeSeries/inputdata_timeseries_updated.rda")
#prediction_result <- data.frame()
## 1. define period for training data: 2013-12-31 < training data < 2016-06-03
define_constants <- function (st,en,al,pred_start,pred_end){
# there is a leap year within this period (2016), hence we need to add one more day
return(list("start_date"=as.Date(st),
"end_date"=as.Date(en),
"training_days_total"= as.numeric(as.Date(en) - as.Date(st)) + 1,
"alpha_value"=al,
"prediction_period_graph"= as.numeric(as.Date(pred_end) - as.Date(en)),
"days_to_remove"= as.numeric(as.Date(pred_end) - as.Date(en)) - as.numeric(as.Date(pred_end)+1 - as.Date(pred_start))))
}
## 2. define training data
define_trainingdata <- function(data,constants=NULL){
return (data[(data[,4] > (constants[[1]] - 1) & data[,4] < (constants[[2]] + 1)),])
}
## 4. Helper functions for time series prediction
# 4.1 alpha value
set_alpha_value <- function(data){
dataPerCalendaryear <- split(data,data$CALENDARYEAR)
firstYear <- as.character(max(data[,1])-2)
zeroValues <- list(dataPerCalendaryear[[1]][(dataPerCalendaryear[[1]][,3] == 0),],
dataPerCalendaryear[[2]][(dataPerCalendaryear[[2]][,3] == 0),],
dataPerCalendaryear[[3]][(dataPerCalendaryear[[3]][,3] == 0),])
denominator <- length(zeroValues[[1]][,1]) + length(zeroValues[[2]][,1]) + length(zeroValues[[3]][,1])
if (length(zeroValues[[1]][,1]) > length(zeroValues[[2]][,1])){
return (1 - (length(zeroValues[[1]][,1])/denominator))
}
return (1 - (length(zeroValues[[1]][,1])/denominator))
}
# 4.2 Holt-Winters method
calculate_HoltWinters <- function(data,alpha_value,days){
exp_smooth_data.hw <- HoltWinters(data, alpha= alpha_value, beta=FALSE, gamma=TRUE)
# prediction based on HoltWinters-Verfahren
return (predict(exp_smooth_data.hw, n.ahead=1*days))
}
handle_HW <- function(data,len,constants,label){
tsdata <- NULL
alpha_value <- constants[[4]]
number_zero_values <- len
if (number_zero_values > constants[["training_days_total"]] * 0.2) {
alpha_value <- set_alpha_value(data)
}
# conversion into a time series object
if (label == "allo") {
tsdata <- ts(data$ALLOCATION, start = c(2018,1), freq=365)} else{
tsdata <- ts(data$CAPACITY, start = c(2018,1), freq=365)
}
# prediction based on HoltWinters-Verfahren
predictiondata <- calculate_HoltWinters(tsdata,alpha_value,constants$prediction_period_graph)
return(list("prediction"=predictiondata,"timeseries"=tsdata,"alpha"=alpha_value))
}
calculate_time_series <- function (data,constants){
timeseriesdata_allokation <- NULL
timeseriesdata_kapa <- NULL
graphdata_allokation <- NULL
graphdata_kapa <- NULL
reportdata_allokation <- NULL
reportdata_kapa <- NULL
alpha_allo <- NULL
alpha_kapa <- NULL
for (i in c("allo","kapa")){
if (i == "allo"){
predictiondata <- handle_HW(data,length(subset(data, data[,3] == 0)[,1]),constants,label="allo")
#browser()
graphdata_allokation <- predictiondata[["prediction"]]
reportdata_allokation <- predictiondata[["prediction"]][-(1:constants$days_to_remove)]
timeseriesdata_allokation <- predictiondata[["timeseries"]]
alpha_allo <- predictiondata[["alpha"]]
#browser()
} else {
predictiondata <- handle_HW(data,length(subset(data, data[,4] == 0)[,1]),constants,label="kapa")
graphdata_kapa <- predictiondata[["prediction"]]
reportdata_kapa <- predictiondata[["prediction"]][-(1:constants$days_to_remove)]
timeseriesdata_kapa <- predictiondata[["timeseries"]]
alpha_kapa <- predictiondata[["alpha"]]
#browser()
}
#browser()
return (list("graphdata_allo"= graphdata_allokation, "reportdata_allo"= reportdata_allokation,
"graphdata_kapa"= graphdata_kapa, "reportdata_kapa"= reportdata_kapa,
"ts_allo"=timeseriesdata_allokation,"ts_kapa"=timeseriesdata_kapa,
"alpha_allo"=alpha_allo,"alpha_kapa"=alpha_kapa))
}
populate_dataframe <- function(allo,kapa,prediction_year,ort,ptype){
start <- as.Date(paste('01-01-',prediction_year,sep=""), format = "%d-%m-%Y")
end <- as.Date(paste('31-12-',prediction_year,sep=""), format = "%d-%m-%Y")
days <- seq(start, end, by = "day")
oname <- rep(ort, 365)
pointtype <- rep(ptype, 365)
header_allo <- paste("PREDICTION_ALLOCATION_",prediction_year,sep="")
df <- data.frame("DATE"=days,"POINTTYPE"=ptype,"STATION"=oname,"allo"=allo,"kapa"=kapa)
names(df)[4]=paste("PREDICTION_ALLOCATION_",prediction_year,sep="")
names(df)[5]=paste("PREDICTION_CAPACITY_",prediction_year,sep="")
return(df)
}
draw_graph <- function(data){
basicPath <- "C:/Users/tpolzer/Documents/Plots/"
doPlot <- function(measure,message,tsdata,predictiondata,alpha){
path <- paste(basicPath,data[[7]],measure,"action_", message, ".pdf")
pdf(file = path)
par(mfrow = c(3, 1), mar = c(4, 4, 2, 1), oma = c(0, 0, 2, 0), lwd=3)
plot(tsdata)
abline(reg = lm(tsdata~time(tsdata)), col="red")
title(paste("Historical data and trend for: ",data[[7]]))
plot(predictiondata)
title(paste(measure,":","Prediction for: ",data[[7]], "ALPHA value: ", round(alpha,3)))
ts.plot(tsdata, predictiondata, lty=1:2, col= c("red", "blue"))
title(paste(measure,":","Prediction for: ",data[[7]], "ALPHA value: ", round(alpha,3)))
dev.off()
}
for (i in c("allo","kapa")){
message <- c("OKAY")
if (i == "allo"){
alpha <- data[[3]]
if (alpha<= 0.2 || alpha >= 0.9) {message <- c("CHECK")}
doPlot("Allocation",message,data[[1]],data[[2]],alpha)
} else {
alpha <- data[[6]]
if (alpha<= 0.2 || alpha >= 0.9) {message <- c("CHECK")}
doPlot("Capacity",message,data[[1]],data[[2]],alpha)
}
## execute
for (ortna in ortnas){
## filter allokation data (Gastag and allocation value) and entry type (Punkttyp = 1)
input_data_entry <- subset(partitionedByOrtna[[ortna]][,3:6], partitionedByOrtna[[ortna]][,1]==1)
max(partitionedByOrtna[[ortna]][,3])
if (length(input_data_entry[,1]) == constants$training_days_total){
prediction_entry <- calculate_time_series(input_data_entry,constants)
df <- populate_dataframe(prediction_entry$reportdata_allo, prediction_entry$reportdata_kapa,
max(partitionedByOrtna[[ortna]][,3])+1,ortna,c("entry"))
prediction_result <<- rbind(prediction_result,df)
draw_graph(list(prediction_entry$ts_allo,prediction_entry$graphdata_allo,prediction_entry$alpha_allo,
prediction_entry$ts_kapa,prediction_entry$graphdata_kapa,prediction_entry$alpha_kapa,ortna))
} else {
print(paste(ortna,c("not enough data available: no prediction possible"),sep=":"))
}
doTimeseriesAnalysis <- function(path){
## define input data
input <- NULL
if (substr(path,nchar(path)-3,nchar(path)) == ".csv"){
input <- read.csv(path,header=TRUE,  stringsAsFactors = FALSE)
} else if (substr(path,nchar(path)-3,nchar(path)) == ".rda" || substr(path,nchar(path)-5,nchar(path)) == ".RData"){
load(path)
} else {
return ("Invalid Path: No file was found")
}
## define constants
constants <- define_constants('2018-01-01','2020-06-02',0.8,'2021-01-01', '2021-12-31')
trainingdata <- define_trainingdata(input, constants)
#browser()
## 3. split entire trainingdata into one dataframe per Ortname
partitionedByOrtna <- split(trainingdata,trainingdata$STATION)
ortnas <- names(partitionedByOrtna)
browser()
## execute
for (ortna in ortnas){
## filter allokation data (Gastag and allocation value) and entry type (Punkttyp = 1)
input_data_entry <- subset(partitionedByOrtna[[ortna]][,3:6], partitionedByOrtna[[ortna]][,1]==1)
max(partitionedByOrtna[[ortna]][,3])
if (length(input_data_entry[,1]) == constants$training_days_total){
prediction_entry <- calculate_time_series(input_data_entry,constants)
#browser()
df <- populate_dataframe(prediction_entry$reportdata_allo, prediction_entry$reportdata_kapa,
max(partitionedByOrtna[[ortna]][,3])+1,ortna,c("household"))
prediction_result <<- rbind(prediction_result,df)
#browser()
draw_graph(list(prediction_entry$ts_allo,prediction_entry$graphdata_allo,prediction_entry$alpha_allo,
prediction_entry$ts_kapa,prediction_entry$graphdata_kapa,prediction_entry$alpha_kapa,ortna))
} else {
print(paste(ortna,c("not enough data available: no prediction possible"),sep=":"))
}
return (prediction_result)
}
prediction_result <- data.frame()
datapath <- "C:/Users/tpolzer/OneDrive - DXC Production/Documents/Analytics_Training_UseCase/Data/Mengenvorhersage/inputdata_timeseries.csv"
result <- doTimeseriesAnalysis(datapath)
rm(list=ls())
#input <- read.csv("C:/Users/tpolzer/OneDrive - DXC Production/Documents/Analytics_Training_UseCase/Data/TimeSeries/inputdata_timeseries_updated.csv",header=TRUE,  stringsAsFactors = FALSE)
#save(input,file="C:/Users/tpolzer/OneDrive - DXC Production/Documents/Analytics_Training_UseCase/Data/TimeSeries/inputdata_timeseries_updated.rda")
#load("C:/Users/tpolzer/OneDrive - DXC Production/Documents/Analytics_Training_UseCase/Data/TimeSeries/inputdata_timeseries_updated.rda")
#prediction_result <- data.frame()
## 1. define period for training data: 2013-12-31 < training data < 2016-06-03
define_constants <- function (st,en,al,pred_start,pred_end){
# there is a leap year within this period (2016), hence we need to add one more day
return(list("start_date"=as.Date(st),
"end_date"=as.Date(en),
"training_days_total"= as.numeric(as.Date(en) - as.Date(st)) + 1,
"alpha_value"=al,
"prediction_period_graph"= as.numeric(as.Date(pred_end) - as.Date(en)),
"days_to_remove"= as.numeric(as.Date(pred_end) - as.Date(en)) - as.numeric(as.Date(pred_end)+1 - as.Date(pred_start))))
}
## 2. define training data
define_trainingdata <- function(data,constants=NULL){
return (data[(data[,4] > (constants[[1]] - 1) & data[,4] < (constants[[2]] + 1)),])
}
## 4. Helper functions for time series prediction
# 4.1 alpha value
set_alpha_value <- function(data){
dataPerCalendaryear <- split(data,data$CALENDARYEAR)
firstYear <- as.character(max(data[,1])-2)
zeroValues <- list(dataPerCalendaryear[[1]][(dataPerCalendaryear[[1]][,3] == 0),],
dataPerCalendaryear[[2]][(dataPerCalendaryear[[2]][,3] == 0),],
dataPerCalendaryear[[3]][(dataPerCalendaryear[[3]][,3] == 0),])
denominator <- length(zeroValues[[1]][,1]) + length(zeroValues[[2]][,1]) + length(zeroValues[[3]][,1])
if (length(zeroValues[[1]][,1]) > length(zeroValues[[2]][,1])){
return (1 - (length(zeroValues[[1]][,1])/denominator))
}
return (1 - (length(zeroValues[[1]][,1])/denominator))
}
# 4.2 Holt-Winters method
calculate_HoltWinters <- function(data,alpha_value,days){
exp_smooth_data.hw <- HoltWinters(data, alpha= alpha_value, beta=FALSE, gamma=TRUE)
# prediction based on HoltWinters-Verfahren
return (predict(exp_smooth_data.hw, n.ahead=1*days))
}
handle_HW <- function(data,len,constants,label){
tsdata <- NULL
alpha_value <- constants[[4]]
number_zero_values <- len
if (number_zero_values > constants[["training_days_total"]] * 0.2) {
alpha_value <- set_alpha_value(data)
}
# conversion into a time series object
if (label == "allo") {
tsdata <- ts(data$ALLOCATION, start = c(2018,1), freq=365)} else{
tsdata <- ts(data$CAPACITY, start = c(2018,1), freq=365)
}
# prediction based on HoltWinters-Verfahren
predictiondata <- calculate_HoltWinters(tsdata,alpha_value,constants$prediction_period_graph)
return(list("prediction"=predictiondata,"timeseries"=tsdata,"alpha"=alpha_value))
}
calculate_time_series <- function (data,constants){
timeseriesdata_allokation <- NULL
timeseriesdata_kapa <- NULL
graphdata_allokation <- NULL
graphdata_kapa <- NULL
reportdata_allokation <- NULL
reportdata_kapa <- NULL
alpha_allo <- NULL
alpha_kapa <- NULL
for (i in c("allo","kapa")){
if (i == "allo"){
predictiondata <- handle_HW(data,length(subset(data, data[,3] == 0)[,1]),constants,label="allo")
#browser()
graphdata_allokation <- predictiondata[["prediction"]]
reportdata_allokation <- predictiondata[["prediction"]][-(1:constants$days_to_remove)]
timeseriesdata_allokation <- predictiondata[["timeseries"]]
alpha_allo <- predictiondata[["alpha"]]
#browser()
} else {
predictiondata <- handle_HW(data,length(subset(data, data[,4] == 0)[,1]),constants,label="kapa")
graphdata_kapa <- predictiondata[["prediction"]]
reportdata_kapa <- predictiondata[["prediction"]][-(1:constants$days_to_remove)]
timeseriesdata_kapa <- predictiondata[["timeseries"]]
alpha_kapa <- predictiondata[["alpha"]]
#browser()
}
#browser()
return (list("graphdata_allo"= graphdata_allokation, "reportdata_allo"= reportdata_allokation,
"graphdata_kapa"= graphdata_kapa, "reportdata_kapa"= reportdata_kapa,
"ts_allo"=timeseriesdata_allokation,"ts_kapa"=timeseriesdata_kapa,
"alpha_allo"=alpha_allo,"alpha_kapa"=alpha_kapa))
}
populate_dataframe <- function(allo,kapa,prediction_year,ort,ptype){
start <- as.Date(paste('01-01-',prediction_year,sep=""), format = "%d-%m-%Y")
end <- as.Date(paste('31-12-',prediction_year,sep=""), format = "%d-%m-%Y")
days <- seq(start, end, by = "day")
oname <- rep(ort, 365)
pointtype <- rep(ptype, 365)
header_allo <- paste("PREDICTION_ALLOCATION_",prediction_year,sep="")
df <- data.frame("DATE"=days,"POINTTYPE"=ptype,"STATION"=oname,"allo"=allo,"kapa"=kapa)
names(df)[4]=paste("PREDICTION_ALLOCATION_",prediction_year,sep="")
names(df)[5]=paste("PREDICTION_CAPACITY_",prediction_year,sep="")
return(df)
}
draw_graph <- function(data){
basicPath <- "C:/Users/tpolzer/Documents/Plots/"
doPlot <- function(measure,message,tsdata,predictiondata,alpha){
path <- paste(basicPath,data[[7]],measure,"action_", message, ".pdf")
pdf(file = path)
par(mfrow = c(3, 1), mar = c(4, 4, 2, 1), oma = c(0, 0, 2, 0), lwd=3)
plot(tsdata)
abline(reg = lm(tsdata~time(tsdata)), col="red")
title(paste("Historical data and trend for: ",data[[7]]))
plot(predictiondata)
title(paste(measure,":","Prediction for: ",data[[7]], "ALPHA value: ", round(alpha,3)))
ts.plot(tsdata, predictiondata, lty=1:2, col= c("red", "blue"))
title(paste(measure,":","Prediction for: ",data[[7]], "ALPHA value: ", round(alpha,3)))
dev.off()
}
for (i in c("allo","kapa")){
message <- c("OKAY")
if (i == "allo"){
alpha <- data[[3]]
if (alpha<= 0.2 || alpha >= 0.9) {message <- c("CHECK")}
doPlot("Allocation",message,data[[1]],data[[2]],alpha)
} else {
alpha <- data[[6]]
if (alpha<= 0.2 || alpha >= 0.9) {message <- c("CHECK")}
doPlot("Capacity",message,data[[1]],data[[2]],alpha)
}
## execute
for (ortna in ortnas){
## filter allokation data (Gastag and allocation value) and entry type (Punkttyp = 1)
input_data_entry <- subset(partitionedByOrtna[[ortna]][,3:6], partitionedByOrtna[[ortna]][,1]==1)
max(partitionedByOrtna[[ortna]][,3])
if (length(input_data_entry[,1]) == constants$training_days_total){
prediction_entry <- calculate_time_series(input_data_entry,constants)
df <- populate_dataframe(prediction_entry$reportdata_allo, prediction_entry$reportdata_kapa,
max(partitionedByOrtna[[ortna]][,3])+1,ortna,c("entry"))
prediction_result <<- rbind(prediction_result,df)
draw_graph(list(prediction_entry$ts_allo,prediction_entry$graphdata_allo,prediction_entry$alpha_allo,
prediction_entry$ts_kapa,prediction_entry$graphdata_kapa,prediction_entry$alpha_kapa,ortna))
} else {
print(paste(ortna,c("not enough data available: no prediction possible"),sep=":"))
}
doTimeseriesAnalysis <- function(path){
## define input data
input <- NULL
if (substr(path,nchar(path)-3,nchar(path)) == ".csv"){
input <- read.csv(path,header=TRUE,  stringsAsFactors = FALSE)
} else if (substr(path,nchar(path)-3,nchar(path)) == ".rda" || substr(path,nchar(path)-5,nchar(path)) == ".RData"){
load(path)
} else {
return ("Invalid Path: No file was found")
}
## define constants
constants <- define_constants('2018-01-01','2020-06-02',0.8,'2021-01-01', '2021-12-31')
trainingdata <- define_trainingdata(input, constants)
#browser()
## 3. split entire trainingdata into one dataframe per Ortname
partitionedByOrtna <- split(trainingdata,trainingdata$STATION)
ortnas <- names(partitionedByOrtna)
#browser()
## execute
for (ortna in ortnas){
## filter allokation data (Gastag and allocation value) and entry type (Punkttyp = 1)
input_data_entry <- subset(partitionedByOrtna[[ortna]][,3:6], partitionedByOrtna[[ortna]][,1]==1)
max(partitionedByOrtna[[ortna]][,3])
if (length(input_data_entry[,1]) == constants$training_days_total){
prediction_entry <- calculate_time_series(input_data_entry,constants)
#browser()
df <- populate_dataframe(prediction_entry$reportdata_allo, prediction_entry$reportdata_kapa,
max(partitionedByOrtna[[ortna]][,3])+1,ortna,c("household"))
prediction_result <<- rbind(prediction_result,df)
#browser()
draw_graph(list(prediction_entry$ts_allo,prediction_entry$graphdata_allo,prediction_entry$alpha_allo,
prediction_entry$ts_kapa,prediction_entry$graphdata_kapa,prediction_entry$alpha_kapa,ortna))
} else {
print(paste(ortna,c("not enough data available: no prediction possible"),sep=":"))
}
return (prediction_result)
}
## placeholder for the final prediction data
prediction_result <- data.frame()
datapath <- "C:/Users/tpolzer/OneDrive - DXC Production/Documents/Analytics_Training_UseCase/Data/Mengenvorhersage/inputdata_timeseries.csv"
result <- doTimeseriesAnalysis(datapath)
<- factor(c("BMW","Audi","Volkswagen","Mercedes-Benz"))
f <- factor(c("BMW","Audi","Volkswagen","Mercedes-Benz"))
f
str(f)
table(f)
levelcount <- table(f)
setwd("C:/Users/tpolzer/Documents/Ubuntu_20_04_SharedFolder/R_Tutorial/")
cars <- load("workspacedata/cardata_binaryFormat.rda")
View(cardata1)
table(cardata1)
table(cardata1$brand)
t <- table(cardata1$brand)
as.vector(t)
?cut()
tx0 <- c(9, 4, 6, 5, 3, 10, 5, 3, 5)
tx0
x <- rep(0:8, tx0)
x
stopifnot(table(x) == tx0)
table( cut(x, b = 8))
?cut()
cut(c(0:8),c(4),labels(TRUE,FALSE))
cut(c(1:8),c(1,4,8),labels=F)
cut(c(1:8),c(0,4,8),labels=("white,blue","green"))
cut(c(1:8),c(0,4,8),labels=("white,"blue","green"))
cut(c(1:8),c(0,4,8),labels=("white","blue","green"))
cut(c(1:8),c(0,4,8),labels=c("white","blue","green"))
cut(rep(1,5), 4)
rep(1,5)
cut(1:6,4)
f
f.levels("Volkswagen","Mercedes-Benz","Porsche","Audi")
orderedFactors <- factor(cardata$brand,levels = c("Volkswagen","Mercedes-Benz","Porsche","Audi"))
orderedFactors <- factor(cardata1$brand,levels = c("Volkswagen","Mercedes-Benz","Porsche","Audi"))
orderedFactors <- factor(cardata1$brand,levels = c("Volkswagen","Mercedes-Benz","BMW","Audi"))
orderedFactors
t <- table(cardata1$brand)
t
orderedFactors <- factor(cardata1$brand,levels = c("Opel","Mercedes","BMW","Audi"))
orderedFactors
orderedLevels <- factor(cardata1$brand,levels = c("Opel","Mercedes","BMW","Audi"))
df <- data.frame(names=c("Revenue.2018","revenue2019","profit.2018","profit2019"),as.matrix(rnorm(3000,120000,50),nrow=1000))
View(df)
df <- data.frame(names <- c("Revenue.2018","revenue2019","profit.2018","profit2019"),as.matrix(rnorm(3000,120000,50),nrow=1000))
View(df)
?data.frame?
?data.frame
df <- data.frame(as.matrix(rnorm(3000,120000,50),nrow=1000, names <- c("Revenue.2018","revenue2019","profit.2018","profit2019"),row.names = FALSE))
df <- data.frame(as.matrix(rnorm(3000,120000,50),nrow=1000), names <- c("Revenue.2018","revenue2019","profit.2018","profit2019"),row.names = FALSE)
## 1. Create some dummy data
df <- data.frame(as.matrix(rnorm(3000,120000,50),nrow=1000), names <- c("Revenue.2018","revenue2019","profit.2018","profit2019"))
View(df)
as.matrix(rnorm(3000,120000,50),nrow=1000)
as.matrix(rnorm(3000,120000,50),nrow=1000,ncol=3)
rnorm(3000,120000,50)
?as.matrix
as.matrix(rnorm(3000,120000,5300),nrow=1000,ncol=3)
a <- rnorm(3000,120000,5300)
as.matrix(a,3,1000)
as.matrix(a,4,1000)
df <- data.frame(matrix(rnorm(3000,120000,5300),nrow=1000), names <- c("Revenue.2018","revenue2019","profit.2018","profit2019"))
View(df)
df <- data.frame(matrix(rnorm(3000,120000,5300),nrow=1000))
View(df)
## 1. Create some dummy data
df <- data.frame(matrix(rnorm(3600,120000,5300),nrow=9000))
View(df)
df <- data.frame(matrix(rnorm(3600,120000,5300),nrow=900))
View(df)
names(df) <- c("Revenue.2018","revenue2019","profit.2018","profit2019")
View(df)
names(df)[1] <- tolower(names(df)[1])
View(df)
splitNames <- strsplit(nemas(df),"\\.")
splitNames <- strsplit(names(df),"\\.")
View(splitNames)
splitNames[1][1]
splitNames[[1]][1]
splitNames[[1]][2]
namesSubstitutedFirstOcc <- sub("\\.","-",names(df))
namesSubstitutedFirstOcc
## 1. Create some dummy data
df <- data.frame(matrix(rnorm(3600,120000,5300),nrow=900))
names(df) <- c("Revenue.fy.2018","revenue2019","profit.fy.2018","profit2019")
# 1. Fixing character vectors - tolower(), toupper()
## Revenue.2018 is the only header with a capital letter, so this should be corrected
names(df)[1] <- tolower(names(df)[1])
# 2. Splitting strings strspilt()
## you might want to remove the dot
## since dot is a reserved character it must be escaped using \\
splitNames <- strsplit(names(df),"\\.")
splitNames[[1]][1]
splitNames[[1]][2]
# sub() replaces the first occurence of a given string by the value of a passed string
namesSubstitutedFirstOcc <- sub("\\.","-",names(df))
namesSubstitutedAllOcc <- sub("\\.","-",names(df))
FirstOcc <- sub("\\.","-",names(df))
# gsub() replaces all occurences of a given character within a string by the value of a passed character
AllOcc <- sub("\\.","-",names(df))
compare <- data.frame(list(FirstOcc,AllOcc))
View(compare)
# gsub() replaces all occurences of a given character within a string by the value of a passed character
AllOcc <- gsub("\\.","-",names(df))
compare <- data.frame(list(FirstOcc,AllOcc))
View(compare)
names(compare) <- c(c("FirstOcc","AllOcc"))
View(compare)
## 1. Create some dummy data
df <- data.frame(matrix(rnorm(3600,120000,5300),nrow=900))
names(df) <- c("Revenue.fy.2018","revenue2019","profit.fy.2018","profit2019")
# 1. Fixing character vectors - tolower(), toupper()
## Revenue.2018 is the only header with a capital letter, so this should be corrected
names(df)[1] <- tolower(names(df)[1])
# 2. Splitting strings strspilt()
## you might want to remove the dot
## since dot is a reserved character it must be escaped using \\
splitNames <- strsplit(names(df),"\\.")
splitNames[[1]][1]
splitNames[[1]][2]
splitNames[[1]][3]
# 3. Substitue strings
# sub() replaces the first occurence of a given character within a string by the value of a passed character
FirstOcc <- sub("\\.","-",names(df))
# gsub() replaces all occurences of a given character within a string by the value of a passed character
AllOcc <- gsub("\\.","-",names(df))
compare <- data.frame(list(FirstOcc,AllOcc))
View(compare)
names(compare) <- c(c("FirstOcc","AllOcc"))
View(compare)
getwd()
load("/workspacedata/cardata.RData")
load("workspacedata/cardata.RData")
View(cardata2)
View(cardata1)
grep("Opel",cardata1$brand)
celebrities <- c("Thomas Müller","Brad Pitt", "Thomas Polzer","Emmanuel Macron","Udo Lindenberg")
grep("Thomas",celebrities)
grep("Thomas",celebrities, value = TRUE)
nchar("zo")
stringLength <- nchar("Usain Bolt")
substr("Manuel Neuer",8,12)
paste("Thomas","Müller")
paste("Thomas","Müller",sep="")
paste(c("Thomas","Müller","Footballplayer"),sep="-")
paste("Thomas","Müller","Footballplayer",sep="-")
paste0
?paste0
paste0("Thomas","Müller")
a =m 1
q=w
a=0
ls(list=rm())
rm(list=ls())
